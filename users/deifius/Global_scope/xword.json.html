{"title": "INASRA", "spine": [["G", "l", "O", "b", "a", "l", "s", "c", "o", "p", "e", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "], [" ", " ", "b", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "], [" ", " ", "j", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "], [" ", " ", "e", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "], [" ", " ", "c", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "], [" ", " ", "t", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "], [" ", " ", "f", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "], [" ", " ", "i", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "], [" ", " ", "l", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "], [" ", " ", "E", "x", "e", "c", "u", "t", "a", "b", "l", "e", "a", "n", "D", "L", "i", "n", "k", "a", "b", "l", "e", "F", "o", "r", "m", "a", "t"], [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "i", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "], [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "g", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "], [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "i", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "], [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "t", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "], [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "a", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "], [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "l", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "], [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "c", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "], [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "O", "p", "t", "i", "m", "F", "R", "O", "G", " ", " ", " ", " ", " ", " "], [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "n", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "], [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "t", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "], [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "a", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "], [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "i", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "], [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "n", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "], [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "e", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "], [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "r", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "], [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "f", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "], [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "o", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "], [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "r", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "], [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "m", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "], [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "a", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "], [" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "t", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "]], "metadata": {"Global_scope": {"links": ["Association list", "Block ", "Cninety-nine", "Transclusion", "Reference ", "Haskell ", "Program state", "Template language", "Referential transparency", "Emacs Lisp", "Lexical analysis", "LIFO ", "Hdl ", "Programming language", "Syntax error", "Switch statement", "Modula-two", "C++", "Name resolution ", "ECMAScript", "Ada ", "Class ", "Method ", "Harold Abelson", "Name binding", "C Sharp ", "Common Lisp", "Scope ", "Nesting ", "Dynamic dispatch", "Closure ", "JavaScript", "Logo ", "Let expression", "Subroutine", "Variable shadowing", "Go ", "Doi ", "Modula", "Forward declaration", "Google Books", "Compile time", "Global variable", "Lisp ", "Project MAC", "C ", "Windows PowerShell", "Debian Almquist shell", "Nested function", "Structure and Interpretation of Computer Programs", "Global variables", "Static global variable", "Functional programming", "ALGOL sixty", "GNU Compiler Collection", "Lookup", "C preprocessor", "Typedef", "ISLISP", "Object-oriented programming", "Maclisp", "Macro expansion", "Name masking", "Control flow", "Variable ", "Expression ", "Bash ", "Wild pointer", "Dangling pointer", "S ", "Identifier", "Computer program", "ML ", "Label ", "Pointer ", "Pascal ", "Single assignment", "Run time ", "Information hiding", "Linker ", "Function type", "Perl", "Swift ", "First-class function", "Storage class", "ISBN ", "Declaration ", "Variable hoisting", "Ternary operator", "Data type", "Source code", "Namespaces", "Object file", "Michael L. Scott", "Self-modifying code", "Steve Russell ", "Anonymous function", "Preprocessor", "Inheritance ", "Local variable", "John McCarthy ", "R ", "Const ", "ALGOL sixty-eight", "Static local variable", "Java ", "Funarg problem", "LaTeX", "For loop", "Automatic variable", "Gerald Jay Sussman", "Computer programming", "KornShell", "Translation unit ", "Object lifetime", "Linkage ", "Funarg", "Undefined behavior", "Computer architecture", "Logic error", "Non-local variable", "Modular programming", "Function prototype", "Call stack", "Forward reference", "Scheme ", "Jinja ", "AngularJS", "Formal semantics of programming languages", "MDL ", "Standard ML", "Thread local storage", "MIT Press", "Macro ", "Immediately-invoked function expression", "Higher-order abstract syntax", "History of the Scheme programming language", "Static variable", "Algol sixty-eight", "Clojure", "Principle of least knowledge", "ALGOL", "StwoCID ", "Stack "], "content": "In computer programming, the scope of a name binding\u2014an association of a name to an entity, such as a variable\u2014is the part of a program where the name binding is valid, that is where the name can be used to refer to the entity. In other parts of the program the name may refer to a different entity (it may have a different binding), or to nothing at all (it may be unbound). The scope of a name binding is also known as the visibility of an entity, particularly in older or more technical literature\u2014this is from the perspective of the referenced entity, not the referencing name.\nThe term \"scope\" is also used to refer to the set of all name bindings that are valid within a part of a program or at a given point in a program, which is more correctly referred to as context or environment.Strictly speaking and in practice for most programming languages, \"part of a program\" refers to a portion of source code (area of text), and is known as lexical scope. In some languages, however, \"part of a program\" refers to a portion of run time (time period during execution), and is known as dynamic scope. Both of these terms are somewhat misleading\u2014they misuse technical terms, as discussed in the definition\u2014but the distinction itself is accurate and precise, and these are the standard respective terms. Lexical scope is the main focus of this article, with dynamic scope understood by contrast with lexical scope.\nIn most cases, name resolution based on lexical scope is relatively straightforward to use and to implement, as in use one can read backwards in the source code to determine to which entity a name refers, and in implementation one can maintain a list of names and contexts when compiling or interpreting a program. Difficulties arise in name masking, forward declarations, and hoisting, while considerably subtler ones arise with non-local variables, particularly in closures.\n\n\n== Definition ==\nThe strict definition of the (lexical) \"scope\" of a name (identifier) is unambiguous\u2014it is \"the portion of source code in which a binding of a name with an entity applies\"\u2014and is virtually unchanged from its 1960 definition in the specification of ALGOL 60. Representative language specifications follow.\n\nALGOL 60 (1960)\nThe following kinds of quantities are distinguished: simple variables, arrays, labels, switches, and procedures. The scope of a quantity is the set of statements and expressions in which the declaration of the identifier associated with that quantity is valid.\nC (2007)\nAn identifier can denote an object; a function; a tag or a member of a structure, union, or enumeration; a typedef name; a label name; a macro name; or a macro parameter. The same identifier can denote different entities at different points in the program. [...] For each different entity that an identifier designates, the identifier is visible (i.e., can be used) only within a region of program text called its scope.\nGo (2013)\nA declaration binds a non-blank identifier to a constant, type, variable, function, label, or package. [...] The scope of a declared identifier is the extent of source text in which the identifier denotes the specified constant, type, variable, function, label, or package.Most commonly \"scope\" refers to when a given name can refer to a given variable\u2014when a declaration has effect\u2014but can also apply to other entities, such as functions, types, classes, labels, constants, and enumerations.\n\n\n=== Lexical scope vs. dynamic scope ===\nA fundamental distinction in scope is what \"part of a program\" means. In languages with lexical scope (also called static scope), name resolution depends on the location in the source code and the lexical context (also called static context), which is defined by where the named variable or function is defined. In contrast, in languages with dynamic scope the name resolution depends upon the program state when the name is encountered which is determined by the execution context (also called runtime context, calling context or dynamic context). In practice, with lexical scope a name is resolved by searching the local lexical context, then if that fails, by searching the outer lexical context, and so on; whereas with dynamic scope, a name is resolved by searching the local execution context, then if that fails, by searching the outer execution context, and so on, progressing up the call stack.Most modern languages use lexical scope for variables and functions, though dynamic scope is used in some languages, notably some dialects of Lisp, some \"scripting\" languages, and some template languages.  Perl 5 offers both lexical and dynamic scope. Even in lexically scoped languages, scope for closures can be confusing to the uninitiated, as these depend on the lexical context where the closure is defined, not where it is called.\nLexical resolution can be determined at compile time, and is also known as early binding, while dynamic resolution can in general only be determined at run time, and thus is known as late binding.\n\n\n=== Related concepts ===\nIn object-oriented programming, dynamic dispatch selects an object method at runtime, though whether the actual name binding is done at compile time or run time depends on the language. De facto dynamic scope is common in macro languages, which do not directly do name resolution, but instead expand in place.\nSome programming frameworks like AngularJS use the term \"scope\" to mean something entirely different than how it is used in this article. In those frameworks the scope is just an object of the programming language that they use (JavaScript in case of AngularJS) that is used in certain ways by the framework to emulate dynamic scope in a language that uses lexical scope for its variables. Those AngularJS scopes can themselves be in context or not in context (using the usual meaning of the term) in any given part of the program, following the usual rules of variable scope of the language like any other object, and using their own inheritance and transclusion rules. In the context of AngularJS, sometimes the term \"$scope\" (with a dollar sign) is used to avoid confusion, but using the dollar sign in variable names is often discouraged by the style guides.\n\n\n== Use ==\nScope is an important component of name resolution, which is in turn fundamental to language semantics. Name resolution (including scope) varies between programming languages, and within a programming language, varies by type of entity; the rules for scope are called scope rules (or scoping rules). Together with namespaces, scope rules are crucial in modular programming, so a change in one part of the program does not break an unrelated part.\n\n\n== Overview ==\n\nWhen discussing scope, there are three basic concepts: scope, extent, and context. \"Scope\" and \"context\" in particular are frequently confused: scope is a property of a name binding, while context is a property of a part of a program, that is either a portion of source code (lexical context or static context) or a portion of run time (execution context, runtime context, calling context or dynamic context). Execution context consists of lexical context (at the current execution point) plus additional runtime state such as the call stack. Strictly speaking, during execution a program enters and exits various name bindings' scopes, and at a point in execution name bindings are \"in context\" or \"not in context\", hence name bindings \"come into context\" or \"go out of context\" as the program execution enters or exits the scope. However, in practice usage is much looser.\nScope is a source-code level concept, and a property of name bindings, particularly variable or function name bindings\u2014names in the source code are references to entities in the program\u2014and is part of the behavior of a compiler or interpreter of a language. As such, issues of scope are similar to pointers, which are a type of reference used in programs more generally. Using the value of a variable when the name is in context but the variable is uninitialized is analogous to dereferencing (accessing the value of) a wild pointer, as it is undefined. However, as variables are not destroyed until they go out of context, the analog of a dangling pointer does not exist.\nFor entities such as variables, scope is a subset of lifetime (also known as extent)\u2014a name can only refer to a variable that exists (possibly with undefined value), but variables that exist are not necessarily visible: a variable may exist but be inaccessible (the value is stored but not referred to within a given context), or accessible but not via the given name, in which case it is not in context (the program is \"out of the scope of the name\"). In other cases \"lifetime\" is irrelevant\u2014a label (named position in the source code) has lifetime identical with the program (for statically compiled languages), but may be in context or not at a given point in the program, and likewise for static variables\u2014a static global variable is in context for the entire program, while a static local variable is only in context within a function or other local context, but both have lifetime of the entire run of the program.\nDetermining which entity a name refers to is known as name resolution or name binding (particularly in object-oriented programming), and varies between languages. Given a name, the language (properly, the compiler or interpreter) checks all entities that are in context for matches; in case of ambiguity (two entities with the same name, such as a global and local variable with the same name), the name resolution rules are used to distinguish them. Most frequently, name resolution relies on an \"inner-to-outer context\" rule, such as the Python LEGB (Local, Enclosing, Global, Built-in) rule: names implicitly resolves to the narrowest relevant context. In some cases name resolution can be explicitly specified, such as by the global and nonlocal keywords in Python; in other cases the default rules cannot be overridden.\nWhen two identical names are in context at the same time, referring to different entities, one says that name masking is occurring, where the higher-priority name (usually innermost) is \"masking\" the lower-priority name. At the level of variables, this is known as variable shadowing. Due to the potential for logic errors from masking, some languages disallow or discourage masking, raising an error or warning at compile time or run time.\nVarious programming languages have various different scope rules for different kinds of declarations and names. Such scope rules have a large effect on language semantics and, consequently, on the behavior and correctness of programs. In languages like C++, accessing an unbound variable does not have well-defined semantics and may result in undefined behavior, similar to referring to a dangling pointer; and declarations or names used outside their scope will generate syntax errors.\nScopes are frequently tied to other language constructs and determined implicitly, but many languages also offer constructs specifically for controlling scope.\n\n\n== Levels of scope ==\nScope can vary from as little as a single expression to as much as the entire program, with many possible gradations in between. The simplest scope rule is global scope\u2014all entities are visible throughout the entire program. The most basic modular scope rule is two-level scope, with a global scope anywhere in the program, and local scope within a function. More sophisticated modular programming allows a separate module scope, where names are visible within the module (private to the module) but not visible outside it. Within a function, some languages, such as C, allow block scope to restrict scope to a subset of a function; others, notably functional languages, allow expression scope, to restrict scope to a single expression. Other scopes include file scope (notably in C) which behaves similarly to module scope, and block scope outside of functions (notably in Perl).\nA subtle issue is exactly when a scope begins and ends. In some languages, such as C, a name's scope begins at its declaration, and thus different names declared within a given block can have different scopes. This requires declaring functions before use, though not necessarily defining them, and requires forward declaration in some cases, notably for mutual recursion. In other languages, such as JavaScript or Python, a name's scope begins at the start of the relevant block (such as the start of a function), regardless of where it is defined, and all names within a given block have the same scope; in JavaScript this is known as variable hoisting. However, when the name is bound to a value varies, and behavior of in-context names that have undefined value differs: in Python use of undefined names yields a runtime error, while in JavaScript undefined names declared with var (but not names declared with let nor const) are usable throughout the function because they are bound to the value undefined.\n\n\n=== Expression scope ===\nThe scope of a name binding is an expression, which is known as expression scope. Expression scope is available in many languages, especially functional languages which offer a feature called let-expressions allowing a declaration's scope to be a single expression. This is convenient if, for example, an intermediate value is needed for a computation. For example, in Standard ML, if f() returns 12, then let val x = f() in x * x end is an expression that evaluates to 144, using a temporary variable named x to avoid calling f() twice. Some languages with block scope approximate this functionality by offering syntax for a block to be embedded into an expression; for example, the aforementioned Standard ML expression could be written in Perl as do { my $x = f(); $x * $x }, or in GNU C as ({ int x = f(); x * x; }).\nIn Python, auxiliary variables in generator expressions and list comprehensions (in Python 3) have expression scope.\nIn C, variable names in a function prototype have expression scope, known in this context as function protocol scope. As the variable names in the prototype are not referred to (they may be different in the actual definition)\u2014they are just dummies\u2014these are often omitted, though they may be used for generating documentation, for instance.\n\n\n=== Block scope ===\nThe scope of a name binding is a block, which is known as block scope. Block scope is available in many, but not all, block-structured programming languages. This began with ALGOL 60, where \"[e]very declaration ... is valid only for that block.\", and today is particularly associated with languages in the Pascal and C families and traditions. Most often this block is contained within a function, thus restricting the scope to a part of a function, but in some cases, such as Perl, the block may not be within a function.\n\nA representative example of the use of block scope is the C code shown here, where two variables are scoped to the loop: the loop variable n, which is initialized once and incremented on each iteration of the loop, and the auxiliary variable n_squared, which is initialized at each iteration. The purpose is to avoid adding variables to the function scope that are only relevant to a particular block\u2014for example, this prevents errors where the generic loop variable i has accidentally already been set to another value. In this example the expression n * n would generally not be assigned to an auxiliary variable, and the body of the loop would simply be written ret += n * n but in more complicated examples auxiliary variables are useful.\nBlocks are primarily used for control flow, such as with if, while, and for loops, and in these cases block scope means the scope of variable depends on the structure of a function's flow of execution. However, languages with block scope typically also allow the use of \"naked\" blocks, whose sole purpose is to allow fine-grained control of variable scope. For example, an auxiliary variable may be defined in a block, then used (say, added to a variable with function scope) and discarded when the block ends, or a while loop might be enclosed in a block that initializes variables used inside the loop that should only be initialized once.\nA subtlety of several programming languages, such as Algol 68 and C (demonstrated in this example and standardized since C99), is that block-scope variables can be declared not only within the body of the block, but also within the control statement, if any. This is analogous to function parameters, which are declared in the function declaration (before the block of the function body starts), and in scope for the whole function body. This is primarily used in for loops, which have an initialization statement separate from the loop condition, unlike while loops, and is a common idiom.\nBlock scope can be used for shadowing. In this example, inside the block the auxiliary variable could also have been called n, shadowing the parameter name, but this is considered poor style due to the potential for errors. Furthermore, some descendants of C, such as Java and C#, despite having support for block scope (in that a local variable can be made to go out of context before the end of a function), do not allow one local variable to hide another. In such languages, the attempted declaration of the second n would result in a syntax error, and one of the n variables would have to be renamed.\nIf a block is used to set the value of a variable, block scope requires that the variable be declared outside of the block. This complicates the use of conditional statements with single assignment. For example, in Python, which does not use block scope, one may initialize a variable as such:\n\nwhere a is accessible after the if statement.\nIn Perl, which has block scope, this instead requires declaring the variable prior to the block:\n\nOften this is instead rewritten using multiple assignment, initializing the variable to a default value. In Python (where it is not necessary) this would be:\n\nwhile in Perl this would be:\n\nIn case of a single variable assignment, an alternative is to use the ternary operator to avoid a block, but this is not in general possible for multiple variable assignments, and is difficult to read for complex logic.\nThis is a more significant issue in C, notably for string assignment, as string initialization can automatically allocate memory, while string assignment to an already initialized variable requires allocating memory, a string copy, and checking that these are successful.\n\nSome languages allow the concept of block scope to be applied, to varying extents, outside of a function. For example, in the Perl snippet at right, $counter is a variable name with block scope (due to the use of the my keyword), while increment_counter is a function name with global scope. Each call to increment_counter will increase the value of $counter by one, and return the new value. Code outside of this block can call increment_counter, but cannot otherwise obtain or alter the value of $counter. This idiom allows one to define closures in Perl.\n\n\n=== Function scope ===\nThe scope of a name binding is a function, which is known as function scope. Function scope is available in most programming languages which offer a way to create a local variable in a function or subroutine: a variable whose scope ends (that goes out of context) when the function returns. In most cases the lifetime of the variable is the duration of the function call\u2014it is an automatic variable, created when the function starts (or the variable is declared), destroyed when the function returns\u2014while the scope of the variable is within the function, though the meaning of \"within\" depends on whether scope is lexical or dynamic. However, some languages, such as C, also provide for static local variables, where the lifetime of the variable is the entire lifetime of the program, but the variable is only in context when inside the function. In the case of static local variables, the variable is created when the program initializes, and destroyed only when the program terminates, as with a static global variable, but is only in context within a function, like an automatic local variable.\nImportantly, in lexical scope a variable with function scope has scope only within the lexical context of the function: it goes out of context when another function is called within the function, and comes back into context when the function returns\u2014called functions have no access to the local variables of calling functions, and local variables are only in context within the body of the function in which they are declared. By contrast, in dynamic scope, the scope extends to the execution context of the function: local variables stay in context when another function is called, only going out of context when the defining function ends, and thus local variables are in context of the function in which they are defined and all called functions. In languages with lexical scope and nested functions, local variables are in context for nested functions, since these are within the same lexical context, but not for other functions that are not lexically nested. A local variable of an enclosing function is known as a non-local variable for the nested function. Function scope is also applicable to anonymous functions.\n\nFor example, in the snippet of Python code on the right, two functions are defined: square and sum_of_squares. square computes the square of a number; sum_of_squares computes the sum of all squares up to a number. (For example, square(4) is 42 = 16, and sum_of_squares(4) is 02 + 12 + 22 + 32 + 42 = 30.)\nEach of these functions has a variable named n that represents the argument to the function. These two n variables are completely separate and unrelated, despite having the same name, because they are lexically scoped local variables with function scope: each one's scope is its own, lexically separate function and thus, they don't overlap. Therefore, sum_of_squares can call square without its own n being altered. Similarly, sum_of_squares has variables named total and i; these variables, because of their limited scope, will not interfere with any variables named total or i that might belong to any other function. In other words, there is no risk of a name collision between these names and any unrelated names, even if they are identical.\nNo name masking is occurring: only one variable named n is in context at any given time, as the scopes do not overlap. By contrast, were a similar fragment to be written in a language with dynamic scope, the n in the calling function would remain in context in the called function\u2014the scopes would overlap\u2014and would be masked (\"shadowed\") by the new n in the called function.\nFunction scope is significantly more complicated if functions are first-class objects and can be created locally to a function and then returned. In this case any variables in the nested function that are not local to it (unbound variables in the function definition, that resolve to variables in an enclosing context) create a closure, as not only the function itself, but also its context (of variables) must be returned, and then potentially called in a different context. This requires significantly more support from the compiler, and can complicate program analysis.\n\n\n=== File scope ===\nThe scope of a name binding is a file, which is known as file scope. File scope is largely particular to C (and C++), where scope of variables and functions declared at the top level of a file (not within any function) is for the entire file\u2014or rather for C, from the declaration until the end of the source file, or more precisely translation unit (internal linking). This can be seen as a form of module scope, where modules are identified with files, and in more modern languages is replaced by an explicit module scope. Due to the presence of include statements, which add variables and functions to the internal context and may themselves call further include statements, it can be difficult to determine what is in context in the body of a file.\nIn the C code snippet above, the function name sum_of_squares has file scope.\n\n\n=== Module scope ===\nThe scope of a name binding is a module, which is known as module scope. Module scope is available in modular programming languages where modules (which may span various files) are the basic unit of a complex program, as they allow information hiding and exposing a limited interface. Module scope was pioneered in the Modula family of languages, and Python (which was influenced by Modula) is a representative contemporary example.\nIn some object-oriented programming languages that lack direct support for modules, such as C++, a similar structure is instead provided by the class hierarchy, where classes are the basic unit of the program, and a class can have private methods. This is properly understood in the context of dynamic dispatch rather than name resolution and scope, though they often play analogous roles. In some cases both these facilities are available, such as in Python, which has both modules and classes, and code organization (as a module-level function or a conventionally private method) is a choice of the programmer.\n\n\n=== Global scope ===\nThe scope of a name binding is an entire program, which is known as global scope. Variable names with global scope\u2014called global variables\u2014are frequently considered bad practice, at least in some languages, due to the possibility of name collisions and unintentional masking, together with poor modularity, and function scope or block scope are considered preferable. However, global scope is typically used (depending on the language) for various other sorts of names, such as names of functions, names of classes and names of other data types. In these cases mechanisms such as namespaces are used to avoid collisions.\n\n\n== Lexical scope vs. dynamic scope ==\nThe use of local variables \u2014 of variable names with limited scope, that only exist within a specific function \u2014 helps avoid the risk of a name collision between two identically named variables. However, there are two very different approaches to answering this question: What does it mean to be \"within\" a function?\nIn lexical scope (or lexical scoping; also called static scope or static scoping), if a variable name's scope is a certain function, then its scope is the program text of the function definition: within that text, the variable name exists, and is bound to the variable's value, but outside that text, the variable name does not exist. By contrast, in dynamic scope (or dynamic scoping), if a variable name's scope is a certain function, then its scope is the time-period during which the function is executing: while the function is running, the variable name exists, and is bound to its value, but after the function returns, the variable name does not exist. This means that if function f invokes a separately defined function g, then under lexical scope, function g does not have access to f's local variables (assuming the text of g is not inside the text of f), while under dynamic scope, function g does have access to f's local variables (since g is invoked during the invocation of f).\n\nConsider, for example, the program on the right. The first line, x=1, creates a global variable x and initializes it to 1. The second line, function g() { echo $x ; x=2 ; }, defines a function g that prints out (\"echoes\") the current value of x, and then sets x to 2 (overwriting the previous value). The third line, function f() { local x=3 ; g ; } defines a function f that creates a local variable x (hiding the identically named global variable) and initializes it to 3, and then calls g. The fourth line, f, calls f. The fifth line, echo $x, prints out the current value of x.\n\nSo, what exactly does this program print? It depends on the scope rules. If the language of this program is one that uses lexical scope, then g prints and modifies the global variable x (because g is defined outside f), so the program prints 1 and then 2. By contrast, if this language uses dynamic scope, then g prints and modifies f's local variable x (because g is called from within f), so the program prints 3 and then 1. (As it happens, the language of the program is Bash, which uses dynamic scope; so the program prints 3 and then 1. If the same code was run with ksh93 which uses lexical scope, the results would be different.)\n\n\n== Lexical scope ==\nWith lexical scope, a name always refers to its lexical context. This is a property of the program text and is made independent of the runtime call stack by the language implementation. Because this matching only requires analysis of the static program text, this type of scope is also called static scope. Lexical scope is standard in all ALGOL-based languages such as Pascal, Modula-2 and Ada as well as in modern functional languages such as ML and Haskell. It is also used in the C language and its syntactic and semantic relatives, although with different kinds of limitations. Static scope allows the programmer to reason about object references such as parameters, variables, constants, types, functions, etc. as simple name substitutions. This makes it much easier to make modular code and reason about it, since the local naming structure can be understood in isolation. In contrast, dynamic scope forces the programmer to anticipate all possible execution contexts in which the module's code may be invoked.\n\nFor example, Pascal is lexically scoped. Consider the Pascal program fragment at right. The variable I is visible at all points, because it is never hidden by another variable of the same name. The char variable K is visible only in the main program because it is hidden by the real variable K visible in procedure B and C only. Variable L is also visible only in procedure B and C but it does not hide any other variable. Variable M is only visible in procedure C and therefore not accessible either from procedure B or the main program. Also, procedure C is visible only in procedure B and can therefore not be called from the main program.\nThere could have been another procedure C declared in the program outside of procedure B. The place in the program where \"C\" is mentioned then determines which of the two procedures named C it represents, thus precisely analogous with the scope of variables.\nCorrect implementation of lexical scope in languages with first-class nested functions is not trivial, as it requires each function value to carry with it a record of the values of the variables that it depends on (the pair of the function and this context is called a closure). Depending on implementation and computer architecture, variable lookup may become slightly inefficient when very deeply lexically nested functions are used, although there are well-known techniques to mitigate this. Also, for nested functions that only refer to their own arguments and (immediately) local variables, all relative locations can be known at compile time. No overhead at all is therefore incurred when using that type of nested function. The same applies to particular parts of a program where nested functions are not used, and, naturally, to programs written in a language where nested functions are not available (such as in the C language).\n\n\n=== History ===\nLexical scope was first used in the early 1960s for the imperative language ALGOL 60 and has been picked up in most other imperative languages since then.Languages like Pascal and C have always had lexical scope, since they are both influenced by the ideas that went into ALGOL 60 and ALGOL 68 (although C did not include lexically nested functions).\nPerl is a language with dynamic scope that added static scope afterwards.\nThe original Lisp interpreter (1960) used dynamic scope. Deep binding, which approximates static (lexical) scope, was introduced around 1962 in LISP 1.5 (via the Funarg device developed by Steve Russell, working under John McCarthy).\nAll early Lisps used dynamic scope, when based on interpreters. In 1982, Guy L. Steele Jr. and the Common LISP Group publish An overview of Common LISP, a short review of the history and the divergent implementations of Lisp up to that moment and a review of the features that a Common Lisp implementation should have. On page 102, we read:\n\nMost LISP implementations are internally inconsistent in that by default the interpreter and compiler may assign different semantics to correct programs; this stems primarily from the fact that the interpreter assumes all variables to be dynamically scoped, while the compiler assumes all variables to be local unless forced to assume otherwise. This has been done for the sake of convenience and efficiency, but can lead to very subtle bugs. The definition of Common LISP avoids such anomalies by explicitly requiring the interpreter and compiler to impose identical semantics on correct programs.\nImplementations of Common LISP were thus required to have lexical scope. Again, from An overview of Common LISP:\n\nIn addition, Common LISP offers the following facilities (most of which are borrowed from MacLisp, InterLisp or Lisp Machines Lisp): (...) Fully lexically scoped variables. The so-called \"FUNARG problem\" is completely solved, in both the downward and upward cases.\nBy the same year in which An overview of Common LISP was published (1982), initial designs (also by Guy L. Steele Jr.) of a compiled, lexically scoped Lisp, called Scheme had been published and compiler implementations were being attempted. At that time, lexical scope in Lisp was commonly feared to be inefficient to implement. In A History of T, Olin Shivers writes:\n\nAll serious Lisps in production use at that time were dynamically scoped. No one who hadn't carefully read the Rabbit thesis (written by Guy Lewis Steele Jr. in 1978) believed lexical scope would fly; even the few people who had read it were taking a bit of a leap of faith that this was going to work in serious production use.\nThe term \"lexical scope\" dates at least to 1967, while the term \"lexical scoping\" dates at least to 1970, where it was used in Project MAC to describe the scope rules of the Lisp dialect MDL (then known as \"Muddle\").\n\n\n== Dynamic scope ==\nWith dynamic scope, a name refers to execution context. It is uncommon in modern languages. In technical terms, this means that each name has a global stack of bindings. Introducing a local variable with name x pushes a binding onto the global x stack (which may have been empty), which is popped off when the control flow leaves the scope. Evaluating x in any context always yields the top binding. Note that this cannot be done at compile-time because the binding stack only exists at run-time, which is why this type of scope is called dynamic scope.\nGenerally, certain blocks are defined to create bindings whose lifetime is the execution time of the block; this adds some features of static scope to the dynamic scope process. However, since a section of code can be called from many different locations and situations, it can be difficult to determine at the outset what bindings will apply when a variable is used (or if one exists at all). This can be beneficial; application of the principle of least knowledge suggests that code avoid depending on the reasons for (or circumstances of) a variable's value, but simply use the value according to the variable's definition. This narrow interpretation of shared data can provide a very flexible system for adapting the behavior of a function to the current state (or policy) of the system. However, this benefit relies on careful documentation of all variables used this way as well as on careful avoidance of assumptions about a variable's behavior, and does not provide any mechanism to detect interference between different parts of a program. Some languages, like Perl and Common Lisp, allow the programmer to choose static or dynamic scope when defining or redefining a variable. Examples of languages that use dynamic scope include Logo, Emacs Lisp, LaTeX and the shell languages bash, dash, and PowerShell.\nDynamic scope is fairly easy to implement. To find an name's value, the program could traverse the runtime stack, checking each activation record (each function's stack frame) for a value for the name. In practice, this is made more efficient via the use of an association list, which is a stack of name/value pairs. Pairs are pushed onto this stack whenever declarations are made, and popped whenever variables go out of context. Shallow binding is an alternative strategy that is considerably faster, making use of a central reference table, which associates each name with its own stack of meanings. This avoids a linear search during run-time to find a particular name, but care should be taken to properly maintain this table. Note that both of these strategies assume a last-in-first-out (LIFO) ordering to bindings for any one variable; in practice all bindings are so ordered.\nAn even simpler implementation is the representation of dynamic variables with simple global variables. The local binding is performed by saving the original value in an anonymous location on the stack that is invisible to the program. When that binding scope terminates, the original value is restored from this location. In fact, dynamic scope originated in this manner. Early implementations of Lisp used this obvious strategy for implementing local variables, and the practice survives in some dialects which are still in use, such as GNU Emacs Lisp. Lexical scope was introduced into Lisp later. This is equivalent to the above shallow binding scheme, except that the central reference table is simply the global variable binding context, in which the current meaning of the variable is its global value. Maintaining global variables isn't complex. For instance, a symbol object can have a dedicated slot for its global value.\nDynamic scope provides an excellent abstraction for thread local storage, but if it is used that way it cannot be based on saving and restoring a global variable. A possible implementation strategy is for each variable to have a thread-local key. When the variable is accessed, the thread-local key is used to access the thread-local memory location (by code generated by the compiler, which knows which variables are dynamic and which are lexical). If the thread-local key does not exist for the calling thread, then the global location is used. When a variable is locally bound, the prior value is stored in a hidden location on the stack. The thread-local storage is created under the variable's key, and the new value is stored there. Further nested overrides of the variable within that thread simply save and restore this thread-local location. When the initial, outermost override's context terminates, the thread-local key is deleted, exposing the global version of the variable once again to that thread.\nWith referential transparency the dynamic scope is restricted to the argument stack of the current function only, and coincides with the lexical scope.\n\n\n=== Macro expansion ===\n\nIn modern languages, macro expansion in a preprocessor is a key example of de facto dynamic scope. The macro language itself only transforms the source code, without resolving names, but since the expansion is done in place, when the names in the expanded text are then resolved (notably free variables), they are resolved based on where they are expanded (loosely \"called\"), as if dynamic scope were occurring.\nThe C preprocessor, used for macro expansion, has de facto dynamic scope, as it does not do name resolution by itself. For example, the macro:\n\nwill expand to add a to the passed variable, with this name only later resolved by the compiler based on where the macro ADD_A is \"called\" (properly, expanded), is in dynamic scope, and is independent of where the macro is defined. Properly, the C preprocessor only does lexical analysis, expanding the macro during the tokenization stage, but not parsing into a syntax tree or doing name resolution.\nFor example, in the following code, the a in the macro is resolved (after expansion) to the local variable at the expansion site:\n\n\n== Qualified names ==\nAs we have seen, one of the key reasons for scope is that it helps prevent name collisions, by allowing identical names to refer to distinct things, with the restriction that the names must have separate scopes. Sometimes this restriction is inconvenient; when many different things need to be accessible throughout a program, they generally all need names with global scope, so different techniques are required to avoid name collisions.\nTo address this, many languages offer mechanisms for organizing global names. The details of these mechanisms, and the terms used, depend on the language; but the general idea is that a group of names can itself be given a name \u2014 a prefix \u2014 and, when necessary, an entity can be referred to by a qualified name consisting of the name plus the prefix. Normally such names will have, in a sense, two sets of scopes: a scope (usually the global scope) in which the qualified name is visible, and one or more narrower scopes in which the unqualified name (without the prefix) is visible as well. And normally these groups can themselves be organized into groups; that is, they can be nested.\nAlthough many languages support this concept, the details vary greatly. Some languages have mechanisms, such as namespaces in C++ and C#, that serve almost exclusively to enable global names to be organized into groups. Other languages have mechanisms, such as packages in Ada and structures in Standard ML, that combine this with the additional purpose of allowing some names to be visible only to other members of their group. And object-oriented languages often allow classes or singleton objects to fulfill this purpose (whether or not they also have a mechanism for which this is the primary purpose). Furthermore, languages often meld these approaches; for example, Perl's packages are largely similar to C++'s namespaces, but optionally double as classes for object-oriented programming; and Java organizes its variables and functions into classes, but then organizes those classes into Ada-like packages.\n\n\n== By language ==\nScope rules for representative languages follow.\n\n\n=== C ===\n\nIn C, scope is traditionally known as linkage or visibility, particularly for variables. C is a lexically scoped language with global scope (known as external linkage), a form of module scope or file scope (known as internal linkage), and local scope (within a function); within a function scopes can further be nested via block scope. However, standard C does not support nested functions.\nThe lifetime and visibility of a variable are determined by its storage class. There are three types of lifetimes in C: static (program execution), automatic (block execution, allocated on the stack), and manual (allocated on the heap). Only static and automatic are supported for variables and handled by the compiler, while manually allocated memory must be tracked manually across different variables. There are three levels of visibility in C: external linkage (global), internal linkage (roughly file), and block scope (which includes functions); block scopes can be nested, and different levels of internal linkage is possible by use of includes. Internal linkage in C is visibility at the translation unit level, namely a source file after being processed by the C preprocessor, notably including all relevant includes.\nC programs are compiled as separate object files, which are then linked into an executable or library via a linker. Thus name resolution is split across the compiler, which resolves names within a translation unit (more loosely, \"compilation unit\", but this is properly a different concept), and the linker, which resolves names across translation units; see linkage for further discussion.\nIn C, variables with block scope enter context when they are declared (not at the top of the block), go out of context if any (non-nested) function is called within the block, come back into context when the function returns, and go out of context at the end of the block. In the case of automatic local variables, they are also allocated on declaration and deallocated at the end of the block, while for static local variables, they are allocated at program initialization and deallocated at program termination.\nThe following program demonstrates a variable with block scope coming into context partway through the block, then exiting context (and in fact being deallocated) when the block ends:\n\nThe program outputs:\n\nm\nm\nb\nm\n\nThere are other levels of scope in C. Variable names used in a function prototype have function prototype visibility, and exit context at the end of the function prototype. Since the name is not used, this is not useful for compilation, but may be useful for documentation. Label names for GOTO statement have function scope, while case label names for switch statements have block scope (the block of the switch).\n\n\n=== C++ ===\nAll the variables that we intend to use in a program must have been declared with its type specifier in an earlier\npoint in the code, like we did in the previous code at the beginning of the body of the function main when we\ndeclared that a, b, and result were of type int.\nA variable can be either of global or local scope. A global variable is a variable declared in the main body of the\nsource code, outside all functions, while a local variable is one declared within the body of a function or a block.\nModern versions allow nested lexical scope.\n\n\n=== Swift ===\nSwift has a similar rule for scopes with C++, but contains different access modifiers.\n\n\n=== Go ===\nGo is lexically scoped using blocks.\n\n\n=== Java ===\nJava is lexically scoped.\nA Java class can contain three types of variables:\nLocal variables\nare defined inside a method, or a particular block. These variables are local to where they were defined and lower levels. For example, a loop inside a method can use that method's local variables, but not the other way around. The loop's variables (local to that loop) are destroyed as soon as the loop ends.Member variables\nalso called fields are variables declared within the class, outside of any method. By default, these variables are available for all methods within that class and also for all classes in the package.Parameters\nare variables in method declarations.In general, a set of brackets defines a particular scope, but variables at top level within a class can differ in their behavior depending on the modifier keywords used in their definition.\nThe following table shows the access to members permitted by each modifier.\n\n\n=== JavaScript ===\nJavaScript has simple scope rules, but variable initialization and name resolution rules can cause problems, and the widespread use of closures for callbacks means the lexical context of a function when defined (which is used for name resolution) can be very different from the lexical context when it is called (which is irrelevant for name resolution). JavaScript objects have name resolution for properties, but this is a separate topic.\nJavaScript has lexical scope  nested at the function level, with the global context being the outermost context. This scope is used for both variables and for functions (meaning function declarations, as opposed to variables of function type). Block scope with the let and const keywords is standard since ECMAScript 6. Block scope can be produced by wrapping the entire block in a function and then executing it; this is known as the immediately-invoked function expression (IIFE) pattern.\nWhile JavaScript scope is simple\u2014lexical, function-level\u2014the associated initialization and name resolution rules are a cause of confusion. Firstly, assignment to a name not in scope defaults to creating a new global variable, not a local one. Secondly, to create a new local variable one must use the var keyword; the variable is then created at the top of the function, with value undefined and the variable is assigned its value when the assignment expression is reached:\n\nA variable with an Initialiser is assigned the value of its AssignmentExpression when the VariableStatement is executed, not when the variable is created.This is known as variable hoisting\u2014the declaration, but not the initialization, is hoisted to the top of the function. Thirdly, accessing variables before initialization yields undefined, rather than a syntax error. Fourthly, for function declarations, the declaration and the initialization are both hoisted to the top of the function, unlike for variable initialization. For example, the following code produces a dialog with output undefined, as the local variable declaration is hoisted, shadowing the global variable, but the initialization is not, so the variable is undefined when used:\n\nFurther, as functions are first-class objects in JavaScript and are frequently assigned as callbacks or returned from functions, when a function is executed, the name resolution depends on where it was originally defined (the lexical context of the definition), not the lexical context or execution context where it is called. The nested scopes of a particular function (from most global to most local) in JavaScript, particularly of a closure, used as a callback, are sometimes referred to as the scope chain, by analogy with the prototype chain of an object.\nClosures can be produced in JavaScript by using nested functions, as functions are first-class objects. Returning a nested function from an enclosing function includes the local variables of the enclosing function as the (non-local) lexical context of the returned function, yielding a closure. For example:\n\nClosures are frequently used in JavaScript, due to being used for callbacks. Indeed, any hooking of a function in the local context as a callback or returning it from a function creates a closure if there are any unbound variables in the function body (with the context of the closure based on the nested scopes of the current lexical context, or \"scope chain\"); this may be accidental. When creating a callback based on parameters, the parameters must be stored in a closure, otherwise it will accidentally create a closure that refers to the variables in the enclosing context, which may change.Name resolution of properties of JavaScript objects is based on inheritance in the prototype tree\u2014a path to the root in the tree is called a prototype chain\u2014and is separate from name resolution of variables and functions.\n\n\n=== Lisp ===\nLisp dialects have various rules for scope.\nThe original Lisp used dynamic scope; it was Scheme, inspired by ALGOL, that introduced static (lexical) scope to the Lisp family.\nMaclisp used dynamic scope by default in the interpreter and lexical scope by default in compiled code, though compiled code could access dynamic bindings by use of SPECIAL declarations for particular variables. However, Maclisp treated lexical binding more as an optimization than one would expect in modern languages, and it did not come with the closure feature one might expect of lexical scope in modern Lisps. A separate operation, *FUNCTION, was available to somewhat clumsily work around some of that issue.Common Lisp adopted lexical scope from Scheme, as did Clojure.\nISLISP has lexical scope for ordinary variables. It also has dynamic variables, but they are in all cases explicitly marked; they must be defined by a defdynamic special form, bound by a dynamic-let special form, and accessed by an explicit dynamic special form.Some other dialects of Lisp, like Emacs Lisp, still use dynamic scope by default. Emacs Lisp now has lexical scope available on a per-buffer basis.\n\n\n=== Python ===\nFor variables, Python has function scope, module scope, and global scope. Names enter context at the start of a scope (function, module, or global scope), and exit context when a non-nested function is called or the scope ends. If a name is used prior to variable initialization, this raises a runtime exception. If a variable is simply accessed (not assigned to), name resolution follows the LEGB (Local, Enclosing, Global, Built-in) rule which resolves names to the narrowest relevant context. However, if a variable is assigned to, it defaults to declaring a variable whose scope starts at the start of the level (function, module, or global), not at the assignment. Both these rules can be overridden with a global or nonlocal (in Python 3) declaration prior to use, which allows accessing global variables even if there is a masking nonlocal variable, and assigning to global or nonlocal variables.\nAs a simple example, a function resolves a variable to the global scope:\n\nNote that x is defined before f is called, so no error is raised, even though it is defined after its reference in the definition of f. Lexically this is a forward reference, which is allowed in Python.\nHere assignment creates a new local variable, which does not change the value of the global variable:\n\nAssignment to a variable within a function causes it to be declared local to the function, hence its scope is the entire function, and thus using it prior to this assignment raises an error. This differs from C, where the scope of the local variable start at its declaration. This code raises an error:\n\nThe default name resolution rules can be overridden with the global or nonlocal (in Python 3) keywords. In the below code, the global x declaration in g means that x resolves to the global variable. It thus can be accessed (as it has already been defined), and assignment assigns to the global variable, rather than declaring a new local variable. Note that no global declaration is needed in f\u2014since it does not assign to the variable, it defaults to resolving to the global variable.\n\nglobal can also be used for nested functions. In addition to allowing assignment to a global variable, as in an unnested function, this can also be used to access the global variable in the presence of a nonlocal variable:\n\nFor nested functions, there is also the nonlocal declaration, for assigning to a nonlocal variable, similar to using global in an unnested function:\n\n\n=== R ===\nR is a lexically scoped language, unlike other implementations of S where the values of free variables are determined by a set of global variables, while in R they are determined by the context in which the function was created. The scope contexts may be accessed using a variety of features (such as parent.frame()) which can simulate the experience of dynamic scope should the programmer desire.\nThere is no block scope:\n\nFunctions have access to scope they were created in:\n\nVariables created or modified within a function stay there:\n\nVariables created or modified within a function stay there unless assignment to enclosing scope is explicitly requested:\n\nAlthough R has lexical scope by default, function scopes can be changed:\n\n\n== See also ==\nClosure (computer science)\nGlobal variable\nLocal variable\nLet expression\nNon-local variable\nName binding\nName resolution (programming languages)\nVariables (scope and extent)\nInformation hiding\nImmediately-invoked function expressions in Javascript\nObject lifetime\n\n\n== Notes ==\n\n\n== References ==", "images": ["https://upload.wikimedia.org/wikipedia/commons/1/1c/Wiki_letter_w_cropped.svg", "https://upload.wikimedia.org/wikipedia/en/9/99/Question_book-new.svg"], "summary": "In computer programming, the scope of a name binding\u2014an association of a name to an entity, such as a variable\u2014is the part of a program where the name binding is valid, that is where the name can be used to refer to the entity. In other parts of the program the name may refer to a different entity (it may have a different binding), or to nothing at all (it may be unbound). The scope of a name binding is also known as the visibility of an entity, particularly in older or more technical literature\u2014this is from the perspective of the referenced entity, not the referencing name.\nThe term \"scope\" is also used to refer to the set of all name bindings that are valid within a part of a program or at a given point in a program, which is more correctly referred to as context or environment.Strictly speaking and in practice for most programming languages, \"part of a program\" refers to a portion of source code (area of text), and is known as lexical scope. In some languages, however, \"part of a program\" refers to a portion of run time (time period during execution), and is known as dynamic scope. Both of these terms are somewhat misleading\u2014they misuse technical terms, as discussed in the definition\u2014but the distinction itself is accurate and precise, and these are the standard respective terms. Lexical scope is the main focus of this article, with dynamic scope understood by contrast with lexical scope.\nIn most cases, name resolution based on lexical scope is relatively straightforward to use and to implement, as in use one can read backwards in the source code to determine to which entity a name refers, and in implementation one can maintain a list of names and contexts when compiling or interpreting a program. Difficulties arise in name masking, forward declarations, and hoisting, while considerably subtler ones arise with non-local variables, particularly in closures."}, "Object_file": {"links": ["Arm Image Format", "GNU Project", "Profiling ", "Read-only memory", "Programmer", "ISBN ", "Debug symbol", "Debugging", "Microcomputer", "Stabs", "COFF", "Rodata", "Binary File Descriptor library", "Java ", "Library ", "Relocatable Object Module Format", "New Executable", "Stack unwinding", "GOFF", "Assembly language", "Responsiveness", "Compiler", "Preferred Executable Format", "Memory segment", "Comparison of executable file formats", "Mach-O", "Memory management unit", "DWARF", "Comment ", "BSS segment", "SREC ", "Motorola six thousand, eight hundred", "Amiga Hunk", "Constant ", "Portable Executable", "ECOFF", "Intel Memory Model", "Position-independent code", "Python ", "Paper tape", "Shared library", "Linker ", "Dynamic linking", "DOS", "Static variable", "Object code", "Unix", "Data segment", "COM file", "Memory management", "GNU Compiler Collection", "CMD file ", ".exe", "A.out", "Executable and Linkable Format", "Wavefront .obj file", "API", "Machine code", "OS/three hundred and sixty and successors", "MIKBUG", "Windows", "OBJ file", "Metadata", "OS/three hundred and sixty Object File Format", "Executable", "Linux", "Debugging data format", "Loader ", "Porting", "DOS MZ executable", "Code segment", "JavaScript", "Memory-mapped file", "Relocation ", "XCOFF", "Operating system", "Bootstrapping"], "content": "An object file is a computer file containing object code, that is, machine code output of an assembler or compiler. The object code is usually relocatable, and not usually directly executable. There are various formats for object files, and the same machine code can be packaged in different object file formats. An object file may also work like a shared library.\nIn addition to the object code itself, object files may contain metadata used for linking or debugging, including: information to resolve symbolic cross-references between different modules, relocation information, stack unwinding information, comments, program symbols, debugging or profiling information.\n\nThe term \"object program\" dates from at least the 1950s: A term in automatic programming for the machine language program produced by the machine by translating a source program written by the programmer in a language similar to algebraic notation.\nA computer programmer generates object code with a compiler. For example, under Linux the GNU Compiler Collection compiler will generate files which have a .o extension and use the ELF format. On Windows, they have a .obj extension and use the COFF format. A linker is then used to combine the object code into one executable program or library pulling in precompiled system libraries as needed. In contrast, scripts (Python or JavaScript) are interpreted and Java (programming language) programs are compiled into byte-code class files.\n\n\n== Object file formats ==\nThere are many different object file formats; originally each type of computer had its own unique format, but with the advent of Unix and other portable operating systems, some formats, such as COFF and ELF, have been defined and used on different kinds of systems. It is possible for the same file format to be used both as linker input and output, and thus as the library and executable file format. Some formats can contain machine code for different processors, with the correct one chosen by the operating system when the program is loaded.Some systems make a distinction between files which are directly executable and files which require processing by the linker. For example, OS/360 and successors call the first format a load module and the second an object module. In this case the files have entirely different formats.\nThe design and/or choice of an object file format is a key part of overall system design.  It affects the performance of the linker and thus programmer turnaround while a program is being developed. If the format is used for executables, the design also affects the time programs take to begin running, and thus the responsiveness for users.\n\n\n=== Absolute object files ===\nMany early computers, or small microcomputers, support only an absolute object format. Programs are not relocatable; they need to be assembled or compiled to execute at specific, predefined addresses. The file contains no relocation or linkage information. These files can be loaded into read/write memory, or stored in read-only memory. For example, the Motorola 6800 MIKBUG monitor contains a routine to read an absolute object file (SREC Format) from paper tape. DOS COM files are a more recent example of absolute object files.\n\n\n=== Segmentation ===\nMost object file formats are structured as separate sections of data, each section containing a certain type of data. These sections are known as \"segments\" due to the term \"memory segment\", which was previously a common form of memory management. When a program is loaded into memory by a loader, the loader allocates various regions of memory to the program.  Some of these regions correspond to segments of the object file, and thus are usually known by the same names. Others, such as the stack,  only exist at run time. In some cases, relocation is done by the loader (or linker) to specify the actual memory addresses. However, for many programs or architectures, relocation is not necessary, due to being handled by the memory management unit or by position-independent code. On some systems the segments of the object file can then be copied (paged) into memory and executed, without needing further processing. On these systems, this may be done lazily, that is, only when the segments are referenced during execution, for example via a memory-mapped file backed by the object file.\nTypes of data supported by typical object file formats:\nHeader (descriptive and control information)\nCode segment (\"text segment\", executable code)\nData segment (initialized static variables)\nRead-only data segment (rodata, initialized static constants)\nBSS segment (uninitialized static data, both variables and constants)\nExternal definitions and references for linking\nRelocation information\nDynamic linking information\nDebugging informationSegments in different object files may be combined by the linker according to rules specified when the segments are defined. Conventions exist for segments shared between object files; for instance, in DOS there are different memory models that specify the names of special segments and whether or not they may be combined.Debugging information may either be an integral part of the object file format, as in COFF, or a semi-independent format which may be used with several object formats, such as stabs or DWARF.\nThe GNU Project's Binary File Descriptor library (BFD library) provides a common API for the manipulation of object files in a variety of formats.\n\n\n== References ==\n\n\n== Further reading ==\nLevine, John R. (2000). Linkers & Loaders. Morgan Kaufmann Publishers. p. 256. ISBN 1-55860-496-0.", "images": [], "summary": "An object file is a computer file containing object code, that is, machine code output of an assembler or compiler. The object code is usually relocatable, and not usually directly executable. There are various formats for object files, and the same machine code can be packaged in different object file formats. An object file may also work like a shared library.\nIn addition to the object code itself, object files may contain metadata used for linking or debugging, including: information to resolve symbolic cross-references between different modules, relocation information, stack unwinding information, comments, program symbols, debugging or profiling information.\n\nThe term \"object program\" dates from at least the 1950s: A term in automatic programming for the machine language program produced by the machine by translating a source program written by the programmer in a language similar to algebraic notation.\nA computer programmer generates object code with a compiler. For example, under Linux the GNU Compiler Collection compiler will generate files which have a .o extension and use the ELF format. On Windows, they have a .obj extension and use the COFF format. A linker is then used to combine the object code into one executable program or library pulling in precompiled system libraries as needed. In contrast, scripts (Python or JavaScript) are interpreted and Java (programming language) programs are compiled into byte-code class files."}, "Executable_and_Linkable_Format": {"links": ["Berkeley Packet Filter", "Sony Ericsson Wsix hundred and teni", "Motorola eighty-eight thousand", "Intel inine hundred and sixty", "Sony Ericsson Weight hundred", "AROS Research Operating System", "Wii", "Computing", "Syllable Desktop ", "Unix", "UnixWare", "Byte order", "Xeighty-six", "Modding", "NetBSD", "MINIX", "OpenVMS", "AmigaOS four", "Marc Ewing", "ASCII", "System V", "GNU Hurd", "Linus Torvalds", "Texas Instruments", "Amiga Hunk", "AVRthirty-two", "IA-sixty-four", "Free software", ".exe", "Sun Microsystems", "BSDI", "Core dump", "OS/three hundred and sixty Object File Format", "Atmel AVR", "Intel Binary Compatibility Standard", "Position-independent code", "PlayStation two", "NXP ColdFire", "ZSeries", "CMD file ", "Trusixty-four", "Bryan Wayne Sparks", "Symbian", "DWARF", "Comparison of executable file formats", "sixty-four-bit", "The SCO Group", "Stratus VOS", "Android ", "Objdump", "Z/TPF", "IA-thirty-two", "Application binary interface", "File ", "Firmware", "RISC-V", "Assembly Language", "WDC sixty-fiveC816", "System V Release four", "Siemens Csixty-five", "DDC-I", "MorphOS", "Preferred Executable Format", "MSPfour hundred and thirty", "ECOFF", "Mach-O", "Motorola sixty-eightHC12", "MIPS-X", "Morgan Kaufmann", "OpenBSD", "SuperH", "Relocatable Object Module Format", "Run time ", "ISBN ", "System Object Model ", "Height Family", "WDC 65Ceight hundred and sixteen", "Patch ", "Wii U", "Java Native Interface", "Jordan Hubbard", "Executable", "RISC OS", "Readelf", "Single UNIX Specification", "File format", "Jon \"maddog\" Hall", "Solaris ", "Word size", "De facto standard", "LinuxWorld Conference and Expo", "PowerPC", "Bellmac thirty-two", "PlayStation five", "Texas Instruments TMSthree hundred and twenty", "NonStop ", "sixty-four-bit computing", "COM file", "AMDsixty-four", "Binary file", "PlayStation four", "IRIX", "RH-thirty-two", "Fuchsia OS", "Sony Ericsson", "Windows ten Anniversary Update", "Linux", "Unix System Laboratories", "PlayStation Portable", "S/three hundred and ninety", "Redox ", "PlayStation three", "Motorola sixty-eight thousand series", "Itanium", "PA-RISC", "Lxrun", "IBM", "Intel", "Entry point", "Bada", "Siemens", "A.out", "Rthree thousand", "QNX", "Intel ieight hundred and sixty", "ARM architecture", "thirty-two-bit", "DragonFly BSD", "Apple Inc.", "Android Runtime", "Cross-platform", "Filename extension", "IBM System/three hundred and seventy", "BenQ-Siemens ELseventy-one", "PC compatible", "MOS:PROSE", "Samsung Wave Seight thousand, five hundred", "OpenServer", "Instruction set architecture", "Wayback Machine", "Lollipop ", "Nokia Nnine hundred", "Central processing unit", "CloudABI", "GOFF", "Infineon TriCore", "PlayStation ", "Portable Executable", "Dreamcast", "Binary File Descriptor library", "Dynamic linker", "Keith Bostic", "Gamecube", "SkyOS", "Cell ", "Solaris Containers for Linux Applications", "VDSO", "Memory segmentation", "Motorola six thousand, eight hundred", "AArchsixty-four", "HP-UX", "Compatibility layer", "Extended Hunk Format", "Unix-like", "Library ", "Haiku ", "IBM AIX", "Arm Image Format", "OCLC ", "DOS MZ executable", "Byte", "Motorola RAZR Vthree", "Digital Alpha", "Amdsixty-four", "Nokia", "Object file", "SPARC", "FreeBSD", "GNU Binutils", "GPtwoX", "Mthirty-twoR", "Linux Standard Base", "Motorola 68HCtwelve", "XCOFF", "Instruction set", "Open Firmware", "PlayStation Vita", "New Executable", "MIPS architecture", "BeOS", "Windows Subsystem for Linux", "Groklaw", "Motorola SLVR Lseven", "Endianness", "CPU", "Endiannesses", "COFF", "Z/Architecture", "Veight hundred and fifty", "Sony Ericsson Wthree hundred", "Ulrich Drepper", "Illumos", "Motorola", "Fat binary", "Magic number ", "Operating system", "Digital container format", "John R. Levine", "ARC ", "MOS:LIST", "Bruce Perens", "Object code", "Computing platform", "Santa Cruz Operation", "List of Intel processors"], "content": "In computing, the Executable and Linkable Format (ELF, formerly named Extensible Linking Format), is a common standard file format for executable files, object code, shared libraries, and core dumps. First published in the specification for the application binary interface (ABI) of the Unix operating system version named System V Release 4 (SVR4), and later in the Tool Interface Standard, it was quickly accepted among different vendors of Unix systems. In 1999, it was chosen as the standard binary file format for Unix and Unix-like systems on x86 processors by the 86open project.\nBy design, the ELF format is flexible, extensible, and cross-platform. For instance it supports different endiannesses and address sizes so it does not exclude any particular central processing unit (CPU) or instruction set architecture. This has allowed it to be adopted by many different operating systems on many different hardware platforms.\n\n\n== File layout ==\nEach ELF file is made up of one ELF header, followed by file data. The data can include:\n\nProgram header table, describing zero or more memory segments\nSection header table, describing zero or more sections\nData referred to by entries in the program header table or section header table\nThe segments contain information that is needed for run time execution of the file, while sections contain important data for linking and relocation. Any byte in the entire file can be owned by one section at most, and orphan bytes can occur which are unowned by any section.\n\n\n=== File header ===\nThe ELF header defines whether to use 32-bit or 64-bit addresses. The header contains three fields that are affected by this setting and offset other fields that follow them. The ELF header is 52 or 64 bytes long for 32-bit and 64-bit binaries respectively.\n\n\n=== Program header ===\nThe program header table tells the system how to create a process image.  It is found at file offset e_phoff, and consists of e_phnum entries, each with size e_phentsize.  The layout is slightly different in 32-bit ELF vs 64-bit ELF, because the p_flags are in a different structure location for alignment reasons.  Each entry is structured as:\n\n\n=== Section header ===\n\n\n== Tools ==\n\nreadelf is a Unix binary utility that displays information about one or more ELF files. A free software implementation is provided by GNU Binutils.\nelfutils provides alternative tools to GNU Binutils purely for Linux.\nelfdump is a command for viewing ELF information in an ELF file, available under Solaris and FreeBSD.\nobjdump provides a wide range of information about ELF files and other object formats. objdump uses the Binary File Descriptor library as a back-end to structure the ELF data.\nThe Unix file utility can display some information about ELF files, including the instruction set architecture for which the code in a relocatable, executable, or shared object file is intended, or on which an ELF core dump was produced.\n\n\n== Applications ==\n\n\n=== Unix-like systems ===\nThe ELF format has replaced older executable formats in various environments.\nIt has replaced a.out and COFF formats in Unix-like operating systems:\n\nLinux\nSolaris / Illumos\nIRIX\nFreeBSD\nNetBSD\nOpenBSD\nRedox\nDragonFly BSD\nSyllable\nHP-UX (except for 32-bit PA-RISC programs which continue to use SOM)\nQNX Neutrino\nMINIX\n\n\n=== Non-Unix adoption ===\nELF has also seen some adoption in non-Unix operating systems, such as:\n\nOpenVMS, in its Itanium and amd64 versions\nBeOS Revision 4 and later for x86 based computers (where it replaced the Portable Executable format; the PowerPC version stayed with Preferred Executable Format)\nHaiku, an open source reimplementation of BeOS\nRISC OS\nStratus VOS, in PA-RISC and x86 versions\nWindows 10 Anniversary Update using the Windows Subsystem for Linux.\nSkyOS\nFuchsia OS\nZ/TPF\nHPE NonStop OS\n Deos\n\n\n=== Game consoles ===\nSome game consoles also use ELF:\n\nPlayStation Portable, PlayStation Vita, PlayStation (console), PlayStation 2, PlayStation 3, PlayStation 4, PlayStation 5\nGP2X\nDreamcast\nGamecube\nWii\nWii U\n\n\n=== PowerPC ===\nOther (operating) systems running on PowerPC that use ELF:\n\nAmigaOS 4, the ELF executable has replaced the prior Extended Hunk Format (EHF) which was used on Amigas equipped with PPC processor expansion cards.\nMorphOS\nAROS\n\n\n=== Mobile phones ===\nSome operating systems for mobile phones and mobile devices use ELF:\n\nSymbian OS v9 uses E32Image format that is based on the ELF file format;\nSony Ericsson, for example, the W800i, W610, W300, etc.\nSiemens, the SGOLD and SGOLD2 platforms: from Siemens C65 to S75 and BenQ-Siemens E71/EL71;\nMotorola, for example, the E398, SLVR L7, v360, v3i (and all phone LTE2 which has the patch applied).\nBada, for example, the Samsung Wave S8500.\nNokia phones or tablets running the Maemo or the Meego OS, for example, the Nokia N900.\nAndroid uses ELF .so (shared object) libraries for the Java Native Interface. With Android Runtime (ART), the default since Android 5.0 \"Lollipop\", all applications are compiled into native ELF binaries on installation.\nSome phones can run ELF files through the use of a patch that adds assembly code to the main firmware, which is a feature known as ELFPack in the underground modding culture. The ELF file format is also used with the Atmel AVR (8-bit), AVR32\nand with Texas Instruments MSP430 microcontroller architectures. Some implementations of Open Firmware can also load ELF files, most notably Apple's implementation used in almost all PowerPC machines the company produced.\n\n\n== Specifications ==\n\nThe Linux Standard Base (LSB) supplements some of the above specifications for architectures in which it is specified. For example, that is the case for the System V ABI, AMD64 Supplement.\n\n\n== 86open ==\n86open was a project to form consensus on a common binary file format for Unix and Unix-like operating systems on the common PC compatible x86 architecture, to encourage software developers to port to the architecture. The initial idea was to standardize on a small subset of Spec 1170, a predecessor of the Single UNIX Specification, and the GNU C Library (glibc) to enable unmodified binaries to run on the x86 Unix-like operating systems. The project was originally designated \"Spec 150\".\nThe format eventually chosen was ELF, specifically the Linux implementation of ELF, after it had turned out to be a de facto standard supported by all involved vendors and operating systems.\nThe group began email discussions in 1997 and first met together at the Santa Cruz Operation offices on August 22, 1997.\nThe steering committee was Marc Ewing, Dion Johnson, Evan Leibovitch, Bruce Perens, Andrew Roach, Bryan Wayne Sparks and Linus Torvalds. Other people on the project were Keith Bostic, Chuck Cranor, Michael Davidson, Chris G. Demetriou, Ulrich Drepper, Don Dugger, Steve Ginzburg, Jon \"maddog\" Hall, Ron Holt, Jordan Hubbard, Dave Jensen, Kean Johnston, Andrew Josey, Robert Lipe, Bela Lubkin, Tim Marsland, Greg Page, Ronald Joe Record, Tim Ruckle, Joel Silverstein, Chia-pi Tien, and Erik Troan. Operating systems and companies represented were BeOS, BSDI, FreeBSD, Intel, Linux, NetBSD, SCO and SunSoft.\nThe project progressed and in mid-1998, SCO began developing lxrun, an open-source compatibility layer able to run Linux binaries on OpenServer, UnixWare, and Solaris. SCO announced official support of lxrun at LinuxWorld in March 1999. Sun Microsystems began officially supporting lxrun for Solaris in early 1999, and later moved to integrated support of the Linux binary format via Solaris Containers for Linux Applications.\nWith the BSDs having long supported Linux binaries (through a compatibility layer) and the main x86 Unix vendors having added support for the format, the project decided that Linux ELF was the format chosen by the industry and \"declare[d] itself dissolved\" on July 25, 1999.\n\n\n== FatELF: universal binaries for Linux ==\nFatELF is an ELF binary-format extension that adds fat binary capabilities. It is aimed for Linux and other Unix-like operating systems. Additionally to the CPU architecture abstraction (byte order, word size, CPU instruction set etc.), there is the potential advantage of software-platform abstraction e.g., binaries which support multiple kernel ABI versions. As of 2 March 2021, FatELF has not been integrated into the mainline Linux Kernel.\n\n\n== See also ==\n\nApplication binary interface\nComparison of executable file formats\nDWARF \u2013  a format for debugging data\nIntel Binary Compatibility Standard\nPortable Executable \u2013  format used by Windows\nvDSO \u2013  virtual DSO\nPosition-independent code\n\n\n== References ==\n\n\n== Further reading ==\n\n\n== External links ==", "images": ["https://upload.wikimedia.org/wikipedia/commons/e/e4/ELF_Executable_and_Linkable_Format_diagram_by_Ange_Albertini.png", "https://upload.wikimedia.org/wikipedia/commons/7/77/Elf-layout--en.svg", "https://upload.wikimedia.org/wikipedia/commons/6/6f/Octicons-terminal.svg", "https://upload.wikimedia.org/wikipedia/en/f/f2/Edit-clear.svg"], "summary": "In computing, the Executable and Linkable Format (ELF, formerly named Extensible Linking Format), is a common standard file format for executable files, object code, shared libraries, and core dumps. First published in the specification for the application binary interface (ABI) of the Unix operating system version named System V Release 4 (SVR4), and later in the Tool Interface Standard, it was quickly accepted among different vendors of Unix systems. In 1999, it was chosen as the standard binary file format for Unix and Unix-like systems on x86 processors by the 86open project.\nBy design, the ELF format is flexible, extensible, and cross-platform. For instance it supports different endiannesses and address sizes so it does not exclude any particular central processing unit (CPU) or instruction set architecture. This has allowed it to be adopted by many different operating systems on many different hardware platforms."}, "Digital_container_format": {"links": ["Windows Media Center", "Video coding format", "G.seven hundred and nineteen", "Adaptive differential pulse-code modulation", "RealVideo", "Arithmetic coding", "Dolby AC-four", "Dolby Digital", "Resource Interchange File Format", "WinDVD", "Audio Video Interleave", "OCLC ", "Media Go", "MTnine", "MPEG-two", "FITS", "Enhanced VOB", "Mpxplay", "Selectable Mode Vocoder", "YULS", "WebM", "VPnine", "Muine", "VPsix", "Xfce", "CD Player ", "Modified Huffman coding", "MPthree", "JPEG File Interchange Format", "Lossless compression", "Internet Engineering Task Force", "Winamp", "Thor ", "XMMStwo", "Adobe Media Player", "Motion JPEG", "Linux", "Vector sum excited linear prediction", "H.two hundred and sixty-one", "Huffman coding", "Cinepak", "Archive format", "NETVC", "Sorenson Media", "DivX", "Front Row ", "MPEG-four", "High Efficiency Video Coding", "Banshee ", "Windows Media Player", "Wireless Application Protocol Bitmap Format", "Mpgone hundred and twenty-three", "Cmus", "VLC media player", "Half Rate", "H.26four/MPEG-four AVC", "Apple Inc.", "Comparison of audio coding formats", "Speex", "Cross-platform", "Full Rate", "QuickTime Graphics", "VPthree", "Media Player Classic", "XMMS", "Rhythmbox", "Amarok ", "RTAudio", "Lagarith", "Advanced Systems Format", "Microsoft Photos", "Nightingale ", "RealPlayer", "Differential pulse-code modulation", "G.seven hundred and twenty-nine", "SonicStage", "FFmpeg", "Foobartwo thousand", "MSU Lossless Video Codec", "H.two hundred and sixty-four/MPEG-4 AVC", "ZIP ", "G.seven hundred and eleven", "Style Jukebox", "Enhanced Voice Services", "Asao ", "Music Player Daemon", "Blu-ray Disc", "Groove Music", "Au file format", "Code-excited linear prediction", "ETSI", "Fast Fourier transform", "Archive file", "VPseven", "Linear predictive coding", "Adaptive Multi-Rate Wideband", "G.729.one", "Group four compression", "LDAC ", "Ogle DVD Player", "File format", "Electronic program guide", "Entropy encoding", "G.seven hundred and twenty-eight", "Commercial software", "LCEVC", "Variable frame rate", "AIMP", "Microsoft Video one", "QuickTime", "MusikCube", "Real-time Transport Protocol", "A-law algorithm", "Digital container format", "Comparison of video player software", "Theora", "MacOS", "MPEG-four Part 2", "MPEG-4 Part fourteen", "DivX Media Format", "ModfourWin", "List of codecs", "MPEG Multichannel", "VC-six", "Codec two", "Adaptive Multi-Rate audio codec", "MPlayer", "FLAC", "G.seven hundred and twenty-two.1", "threeGP and threeG2", "Advanced Audio Coding", "KMPlayer", "Transform coding", "Peel ", "Mobile device", "Magic number ", "JRiver Media Center", "JPEG XR", "Shorten ", "Bink Video", "MPEG program stream", "Yahoo! Music Jukebox", "Wavelet", "Video Coding Experts Group", "MPEG-I", "Metadata", "MPEG transport stream", "MediaMonkey", "Adobe Systems", "Proprietary software", "TTA ", "QuickTime File Format", "PowerDVD", "G.seven hundred and twenty-two", "JPEG XT", "RealMedia", "AAC-LD", "Miro ", "List of open-source codecs", "AptX", "Apple Lossless", "Better Portable Graphics", "Wavelet transform", "Variable bitrate", "DeaDBeeF", "ISBN ", "Flash Video", "AMV video format", "Kaffeine", "ProRes four hundred and twenty-two", "GIF", "Internet Low Bitrate Codec", "Zinf", "LZseventy-seven and LZ78", "Mpv ", "Free software", "Apple Video", "General Exchange Format", "Serial communications", "CineForm", "Enhanced Variable Rate Codec", "TIFF/IT", "GNOME Videos", "DTS ", "Helix ", "Opus ", "RealAudio", "Huffyuv", "JBIG", "DVR-MS", "threeGPP", "Forward compatibility", "MPEG-four IVC", "Audio Video Standard", "JBIGtwo", "H.one hundred and twenty", "Musepack", "Tagged Image File Format", "Daala", "Songbird ", "TIFF", "Harmonic Vector Excitation Coding", "Tag ", "Motion JPEG two thousand", "Xine", "Baudline", "ISO base media file format", "DVD Player ", "Enhanced Variable Rate Codec B", "Lossy compression", "LHDC ", "Advanced Video Coding", "Elementary OS", "Media player software", "The Core Pocket Media Player", ".mtwots", "Windows Media Video", "InterActual Player", "VC-one", "Data compression", "MPEG-four Part 1four", "Comparison of DVR software packages", "MPEG media transport", "WavPack", "G.seven hundred and twenty-six", "Line spectral pairs", "Extended Adaptive Multi-Rate \u2013 Wideband", "OMS Video", "B-frame", "VPeight", "MPEG-4 Part two", "MediaPortal", "Metafile", "Qualcomm code-excited linear prediction", "JPEG two thousand", "Mac OS", "QuuxPlayer", "JetAudio", "Distinguished Encoding Rules", "H.two hundred and sixty-three", "Modified discrete cosine transform", "MusicBee", "Warped linear predictive coding", "Packetized elementary stream", "Nulloy", "VOB", "JuK", "Image file formats", "MPEG-H threeD Audio", "Video file format", "Relaxed code-excited linear prediction", "Avid DNxHD", "Society of Motion Picture and Television Engineers", "Smacker video", "G.723.one", "Dirac ", "Quod Libet ", "Audio Lossless Coding", "Plex ", "High-Efficiency Advanced Audio Coding", "IINA", "Codec", "MPEG-one Audio Layer II", "Dynamic-link library", "Joint Photographic Experts Group", "Boxee", "Multiple-image Network Graphics", "Freeware", "Connect Player", "Ontwo Technologies", "MPEG Surround", "threeGP", "JPEG-LS", "Modular design", "Comparison of portable media players", "Digital Video Interactive", "OpenEXR", "Essential Video Coding", "DjVu", "DoubleTwist", "Monkey's Audio", "OptimFROG", "FFVone", "Streaming media", "Bit slip", "HEVC Advance", "RTVideo", "Lempel\u2013Ziv\u2013Welch", "Master Quality Authenticated", "WAV", "Internet Speech Audio Codec", "Pulse-code modulation", "Audio Interchange File Format", "RatDVD", "Unified Speech and Audio Coding", "Comparison of video codecs", "Comparison of free software for audio", "Open standard", "Music on Console", "Audio coding format", "Audio file format", "Adaptive Transform Acoustic Coding", "3GP and 3Gtwo", "APNG", "Original Sound Quality", "Xiph.Org Foundation", "BMP file format", "Quintessential Player", "MPEG-five", "G.seven hundred and twenty-three", "Matroska", "TwinVQ", "\u039c-law algorithm", "SheerVideo", "Enhanced full rate", "Image compression", "Qmmp", "MPEG LA", "MPEG-four SLS", "Ogg", "Avid Audio", "QuickTime VR", "Microsoft Windows", "Windows Media Audio", "Mixed-excitation linear prediction", "International Organization for Standardization", "Comparison of audio player software", "International Electrotechnical Commission", "Versatile Video Coding", "G.seven hundred and twenty-nine.1", "Pixlet", "MPEG-4 Part twelve", "ArcSoft", "DVD-Video", "Computer file", "H.two6two/MPEG-two Part two", "JPEG", "Microsoft Movies & TV", "AVone", "SMPlayer", "Clementine ", "Portable Network Graphics", "Interchange File Format", "ITU-T", "JPEG XL", "MPEG-twenty-one", "High Efficiency Image File Format", "Computer program", "Comparison of video container formats", "DEFLATE", "G.722.one", "Dell MediaDirect", "WebP", "PotPlayer", "World Wide Web Consortium", "MPEG-four Part 12", "Algebraic code-excited linear prediction", "Subtitle ", "TIFF/EP", "MPEG elementary stream", "ITunes", "ProRes four thousand, four hundred and forty-four", "TuneWiki", "Discrete wavelet transform", "Audacious ", "G.seven hundred and twenty-three.1", "ISO/IEC base media file format", "Exaile", "Moving Picture Experts Group", "JPEG Network Graphics", "MPEG-one", "G.seven hundred and eighteen", "MOD and TOD", "CELT", "QuickTime Animation", "Cross-platform software", "Kodi ", "MPEG-one Audio Layer I", "Material Exchange Format", "SVOPC", "ICER", "Indeo", "Extensible Music Format ", "Progressive Graphics File", "MPEG-H", "Elementary stream", "Container format ", "Dynamic Resolution Adaptation", "DV", "Multimedia", "Variable-Rate Multimode Wideband", "H.two hundred and sixty-two/MPEG-2 Part 2", "CoreAVC", "Siren ", "Super Audio CD", "SILK", "Vorbis", "Discrete cosine transform", "Free Lossless Image Format", "Daubechies wavelet", "GOM Player", "LZ77 and LZseventy-eight"], "content": "A container format (informally, sometimes called a wrapper) is a file format that allows multiple data streams to be embedded into a single file, usually along with metadata for identifying and further detailing those streams.  Notable examples of container formats include archive files (such as the ZIP format) and formats used for multimedia playback (such as Matroska, MP4, and AVI). Among the earliest cross-platform container formats were Distinguished Encoding Rules and the 1985 Interchange File Format.\n\n\n== Design ==\nAlthough containers may identify how data or metadata is encoded, they do not actually provide instructions about how to decode that data. A program that can open a container must also use an appropriate codec to decode its contents. If the program doesn't have the required algorithm, it can't use the contained data. In these cases, programs usually emit an error message that complains of a missing codec, which users may be able to acquire.\nContainer formats can be made to wrap any kind of data. Though there are some examples of such file formats (e.g. Microsoft Windows's DLL files), most container formats are specialized for specific data requirements. For example, since audio and video streams can be coded and decoded with many different algorithms, a container format may be used to provide the appearance of a single file format to users of multimedia playback software.\n\n\n=== Considerations ===\nThe differences between various container formats arise from five main issues:\n\nPopularity; how widely supported a container is.\nOverhead.  This is the difference in file-size between two files with the same content in a different container.\nSupport for advanced codec functionality.  Older formats such as AVI do not support new codec features like B-frames, VBR audio or VFR video natively. The format may be \"hacked\" to add support, but this creates compatibility problems.\nSupport for advanced content, such as chapters, subtitles, meta-tags, user-data.\nSupport of streaming media.\n\n\n=== Single coding formats ===\nIn addition to pure container formats, which specify only the wrapper but not the coding, a number of file formats specify both a storage layer and the coding, as part of modular design and forward compatibility.\nExamples include JPEG File Interchange Format (JFIF) for containing JPEG data, and Portable Network Graphics (PNG).\nIn principle, coding can be changed while the storage layer is retained; for example, Multiple-image Network Graphics (MNG) uses the PNG container format but provides animation, while JPEG Network Graphics (JNG) puts JPEG encoded data in a PNG container; in both cases however, the different formats have different magic numbers \u2013 the format specifies the coding, though a MNG can contain both PNG-encoded images and JPEG-encoded images.\n\n\n== Multimedia container formats ==\n\nThe container file is used to identify and interleave different data types. Simpler container formats can contain different types of audio formats, while more advanced container formats can support multiple audio and video streams, subtitles, chapter-information, and meta-data (tags) \u2014 along with the synchronization information needed to play back the various streams together. In most cases, the file header, most of the metadata and the synchro chunks are specified by the container format. For example, container formats exist for optimized, low-quality, internet video streaming which differs from high-quality Blu-ray streaming requirements.\nContainer format parts have various names: \"chunks\" as in RIFF and PNG, \"atoms\" in QuickTime/MP4, \"packets\" in MPEG-TS (from the communications term), and \"segments\" in JPEG. The main content of a chunk is called the \"data\" or \"payload\". Most container formats have chunks in sequence, each with a header, while TIFF instead stores offsets.  Modular chunks make it easy to recover other chunks in case of file corruption or dropped frames or bit slip, while offsets result in framing errors in cases of bit slip.\nSome containers are exclusive to audio:\n\nAIFF (IFF file format, widely used on Mac OS platform)\nWAV  (RIFF file format, widely used on Windows platform)\nXMF (Extensible Music Format)Other containers are exclusive to still images:\n\nFITS (Flexible Image Transport System) still images, raw data, and associated metadata.\nTIFF (Tagged Image File Format) still images and associated metadata.Other flexible containers can hold many types of audio and video, as well as other media. The most popular multi-media containers are:\n\n3GP (used by many mobile phones; based on the ISO base media file format)\nASF (container for Microsoft WMA and WMV, which today usually do not use a container)\nAVI (the standard Microsoft Windows container, also based on RIFF)\nDVR-MS (\"Microsoft Digital Video Recording\", proprietary video container format developed by Microsoft based on ASF)\nFlash Video (FLV, F4V) (container for video and audio from Adobe Systems)\nIFF (first platform-independent container format)\nMatroska (MKV) (not limited to any coding format, as it can hold virtually anything; it is an open standard container format)\nMJ2 - Motion JPEG 2000 file format, based on the ISO base media file format which is defined in MPEG-4 Part 12 and JPEG 2000 Part 12\nQuickTime File Format (standard QuickTime video container from Apple Inc.)\nMPEG program stream (standard container for MPEG-1 and MPEG-2 elementary streams on reasonably reliable media such as disks; used also on DVD-Video discs)\nMPEG-2 transport stream (a.k.a. MPEG-TS) (standard container for digital broadcasting and for transportation over unreliable media; used also on Blu-ray Disc video; typically contains multiple video and audio streams, and an electronic program guide)\nMP4 (standard audio and video container for the MPEG-4 multimedia portfolio, based on the ISO base media file format defined in MPEG-4 Part 12 and JPEG 2000 Part 12) which in turn was based on the QuickTime file format.\nOgg (standard container for Xiph.org audio formats Vorbis and Opus and video format Theora)\nRM (RealMedia; standard container for RealVideo and RealAudio)There are many other container formats, such as NUT, MXF, GXF, ratDVD, SVI, VOB and DivX Media Format\n\n\n== See also ==\nArchive format\nComparison of audio coding formats\nComparison of video codecs\nComparison of video container formats\nList of codecs\nList of open-source codecs\n\n\n== References ==\n\n\n== External links ==\nOnline Video File Format Identification Tool - Designed primarily for CCTV video formats and codecs", "images": ["https://upload.wikimedia.org/wikipedia/commons/1/1b/Ambox_question.svg", "https://upload.wikimedia.org/wikipedia/commons/0/0f/Mergefrom.svg", "https://upload.wikimedia.org/wikipedia/en/b/b4/Ambox_important.svg", "https://upload.wikimedia.org/wikipedia/en/9/99/Question_book-new.svg"], "summary": "A container format (informally, sometimes called a wrapper) is a file format that allows multiple data streams to be embedded into a single file, usually along with metadata for identifying and further detailing those streams.  Notable examples of container formats include archive files (such as the ZIP format) and formats used for multimedia playback (such as Matroska, MP4, and AVI). Among the earliest cross-platform container formats were Distinguished Encoding Rules and the 1985 Interchange File Format."}, "OptimFROG": {"links": ["Group four compression", "DTS ", "Selectable Mode Vocoder", "Relaxed code-excited linear prediction", "Packetized elementary stream", "Code-excited linear prediction", "Enhanced VOB", "ZipGenius", "ProRes four thousand, four hundred and forty-four", "Operating system", "Cinepak", "Half Rate", "World Wide Web Consortium", "ZPAQ", "Xvid", "Adaptive Multi-Rate audio codec", "Libvpx", "DV", "Sorenson codec", "VC-six", "Enhanced full rate", "Free Lossless Image Format", "Transform coding", "Smacker video", "Internet Engineering Task Force", "Audio Interchange File Format", "Pax ", "Data compression", "G.seven hundred and eleven", "General Exchange Format", "Lzop", "Sorenson Media", "Bziptwo", "Au file format", "Video Coding Experts Group", "Variable-Rate Multimode Wideband", "The Unarchiver", "AVone", "MPEG-five", "Helix ", "Lempel\u2013Ziv\u2013Welch", "G.723.one", "MPEG-4 Part fourteen", "Matroska", "MPEG-one", "G.seven hundred and nineteen", "Modified discrete cosine transform", "Versatile Video Coding", "MPEG-twenty-one", "ARJ", "Haiku Applications", "MPEG-four Part 2", "Lagarith", "Daubechies wavelet", "VPseven", "G.seven hundred and twenty-nine", "Interchange File Format", "Windows Media Video", "YULS", "MPEG-4 Part two", "VOB", "MPEG media transport", "Adaptive Transform Acoustic Coding", "BMP file format", "LCEVC", "High Efficiency Video Coding", "TUGZip", "ALZip", "H.two6two/MPEG-two Part two", "G.729.one", "LZseventy-seven and LZ78", "DjVu", "QuickTime", "RealMedia", "TTA ", "Indeo", "JPEG", "MPEG-one Audio Layer II", "Arithmetic coding", "Theora", "Lossy compression", "Gzip", "Society of Motion Picture and Television Engineers", "MSU Lossless Video Codec", "H.two hundred and sixty-two/MPEG-2 Part 2", "Nero Digital", "MPEG-four SLS", "G.seven hundred and twenty-two.1", "Extended Adaptive Multi-Rate \u2013 Wideband", "Super Audio CD", "Info-ZIP", "NETVC", "Warped linear predictive coding", "MOD and TOD", "Free software", "Windows Media Encoder", "VPthree", "Lossless compression", "Full Rate", "Metadata", "QuickTime VR", "A-law algorithm", "MPEG-I", "G.722.one", "FFmpeg", "ITU-T", "MPEG-H threeD Audio", "Multiple-image Network Graphics", "\u039c-law algorithm", "MPEG-one Audio Layer I", "CineForm", "OpenHtwo hundred and sixty-four", "Smart Bitrate Control", "SILK", "Portable Network Graphics", "AptX", "ProRes four hundred and twenty-two", "FFVone", "International Organization for Standardization", "Monkey's Audio", "Audio Lossless Coding", "AAC-LD", "Mixed-excitation linear prediction", "TooLAME", "MPEG-H", "Windows Media Audio", "Filzip", "Thor ", "APEvtwo tag", "RealAudio", "ICER", "3GP and 3Gtwo", "Dynamic Resolution Adaptation", "Daala", "MPEG-four Part 1four", "Xtwo hundred and sixty-five", "VPsix", "Snappy ", "High-Efficiency Advanced Audio Coding", "Differential pulse-code modulation", "Avid Audio", "Motion JPEG two thousand", "Enhanced Variable Rate Codec B", "Comparison of audio coding formats", "Software release life cycle", "FAAC", "Hydrogenaudio", "threeivx", "HEVC Advance", "QuickTime File Format", "International Electrotechnical Commission", "RealVideo", "Ogg", "H.two hundred and sixty-three", "Joint Photographic Experts Group", "Microsoft Video one", "Siren ", "DEFLATE", "VC-one", "Dolby Digital", "Advanced Video Coding", "MPEG Surround", "TIFF/IT", "Codec two", "Line spectral pairs", "Enhanced Variable Rate Codec", "seven-Zip", "MPEG Multichannel", "WavPack", "Wireless Application Protocol Bitmap Format", "Lzip", "Software categories", "H.two hundred and sixty-four/MPEG-4 AVC", "PAQ", "LHDC ", "DTS-HD Master Audio", "H.one hundred and twenty", "JBIGtwo", "Nero AAC Codec", "Commercial software", "Real-time Transport Protocol", "Opus ", "Apple Video", "Digital Video Interactive", "Huffman coding", "Adaptive differential pulse-code modulation", "StuffIt Expander", "Shorten ", "BetterZip", "H.26four/MPEG-four AVC", "Zstandard", "Digital container format", "WinAce", "G.seven hundred and twenty-nine.1", "WinRAR", "LDAC ", "Enhanced Voice Services", "ARC ", "OpenEXR", "Resource Interchange File Format", "Blu-code", "Wavelet", "Fast Fourier transform", "WebM", "PKZIP", ".mtwots", "High Efficiency Image File Format", "Qualcomm code-excited linear prediction", "Proprietary software", "Libavcodec", "JPEG XT", "XAD ", "Vorbis", "LHA ", "Apple Lossless", "MTnine", "Linear predictive coding", "Discrete cosine transform", "Huffyuv", "Freeware", "OMS Video", "VPeight", "Ark ", "Pixlet", "Audio Video Interleave", "Internet Low Bitrate Codec", "CoreAVC", "XZ Utils", "KGB Archiver", "G.seven hundred and twenty-two", "Asao ", "Modified Huffman coding", "MPEG LA", "Multimedia", "Dirac ", "JAR ", "Flash Video", "Xtwo hundred and sixty-four", "Fraunhofer FDK AAC", "Adaptive Multi-Rate Wideband", "GIF", "JPEG two thousand", "Xarchiver", "TIFF/EP", "Rzip", "JPEG XR", "LAME", "Image compression", "Master Quality Authenticated", "WinZip", "Material Exchange Format", "JPEG XL", "Audio data compression", "MPEG elementary stream", "Compress", "APNG", "Motion JPEG", "StuffIt", "Avid DNxHD", "QuickTime Graphics", "Progressive Graphics File", "Pack ", "MPEG-four IVC", "GNOME Archive Manager", "Speex", "Algebraic code-excited linear prediction", "Comparison of file archivers", "Musepack", "Software developer", "Essential Video Coding", "Microsoft Windows", "Lthreeenc", "PowerArchiver", "Archive Utility", "Advanced Systems Format", "G.seven hundred and twenty-three", "JBIG", "FreeArc", "Ontwo Technologies", "RTAudio", "G.seven hundred and twenty-six", "RatDVD", "Tar ", "Linux", "SVOPC", "Internet Speech Audio Codec", "FLAC", "Dolby AC-four", "Audio Video Standard", "HDXfour", "CELT", "MPEG program stream", "VPnine", "Wavelet transform", "JPEG-LS", "AMV video format", "SheerVideo", "Vector sum excited linear prediction", "Executable compression", "Audio coding format", "Advanced Audio Coding", "H.two hundred and sixty-one", "WAV", "G.seven hundred and twenty-eight", "RTVideo", "Pulse-code modulation", "Harmonic Vector Excitation Coding", "MacBinary", "threeGP and threeG2", "Unified Speech and Audio Coding", "Video coding format", "Moving Picture Experts Group", "MPEG-four", "G.seven hundred and eighteen", "Bink Video", "Entropy encoding", "TIFF", "MPthree", "LZ77 and LZseventy-eight", "Codec", "Comparison of video codecs", "UPX", "WebP", "Better Portable Graphics", "Lossless data compression", "MPEG-two", "QuickTime Animation", "G.seven hundred and twenty-three.1", "ETSI", "TwinVQ", "DivX", "Discrete wavelet transform", "ISO/IEC base media file format", "MPEG transport stream", "Original Sound Quality", "Darwin ", "PeaZip", "threeGPP", "List of codecs"], "content": "OptimFROG is a proprietary lossless audio data compression codec developed by Florin Ghido. OptimFROG is optimized for very high compression ratios at the expense of encoding and decoding speed.\n\n\n== OptimFROG DualStream ==\nOptimFROG DualStream is a lossy codec, aimed to fill the gap between perceptual coding and lossless coding as OptimFROG DualStream has an option to produce a correction file. This file can be used, in combination with the main lossy-encoded file, for lossless decoding, but not, unlike Wavpack hybrid for instance, for playback.This correction feature is also offered by MPEG-4 SLS and DTS-HD Master Audio.\n\n\n== Technical details ==\n\n\n=== Metadata ===\nBoth OptimFROG file formats use APEv2 tags to store the metadata.\n\n\n== References ==\n\n\n== External links ==\nOfficial website \nOptimFROG at Hydrogenaudio Wiki.", "images": ["https://upload.wikimedia.org/wikipedia/en/b/b4/Ambox_important.svg", "https://upload.wikimedia.org/wikipedia/en/8/8a/OOjs_UI_icon_edit-ltr-progressive.svg"], "summary": "OptimFROG is a proprietary lossless audio data compression codec developed by Florin Ghido. OptimFROG is optimized for very high compression ratios at the expense of encoding and decoding speed."}}, "#render": {"_": "<html hidden><meta charset=utf-8></html><script src=/render.js></script></html>", "css": "/styles.css"}}
